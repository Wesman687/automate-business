# Auth Server Database Integration Guide

This guide explains how the authentication server works with the database, including user retrieval, database schema, and password hashing.

## Database Schema

### Users Table

The authentication system uses a unified `users` table that stores both admin and customer accounts.

**Table Name:** `users`

**Key Fields:**

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    user_type VARCHAR(20) NOT NULL,  -- 'admin' or 'customer'
    status VARCHAR(20) DEFAULT 'active',  -- 'active', 'inactive', 'pending', 'suspended'
    
    -- Identity fields
    name VARCHAR(255),
    username VARCHAR(100) UNIQUE,
    phone VARCHAR(50),
    
    -- Address fields (mainly for customers)
    address TEXT,
    city VARCHAR(100),
    state VARCHAR(100),
    zip_code VARCHAR(20),
    country VARCHAR(100),
    
    -- Business fields (for customers)
    business_name VARCHAR(255),
    business_site VARCHAR(500),
    business_type VARCHAR(255),
    
    -- Admin-specific fields
    is_super_admin BOOLEAN DEFAULT FALSE,
    
    -- Customer-specific fields
    lead_status VARCHAR(50) DEFAULT 'lead',
    notes TEXT,
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    last_login TIMESTAMP WITH TIME ZONE
);
```

**Important Fields for Authentication:**
- `email` - Used as the login identifier (case-insensitive)
- `password_hash` - Bcrypt hashed password (never stored in plain text)
- `user_type` - Either `'admin'` or `'customer'`
- `status` - Must be `'active'` for login to succeed
- `is_super_admin` - Boolean flag for super admin privileges

---

## How Authentication Works

### 1. User Lookup

When a user attempts to login, the system:

```python
# From services/auth_service.py
user = self.db.query(User).filter(User.email.ilike(email)).first()
```

**Key Points:**
- Uses **case-insensitive** email matching (`ilike` in SQLAlchemy)
- Queries the unified `users` table
- Returns `None` if user doesn't exist

### 2. Password Verification

```python
# Password hashing uses bcrypt via passlib
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Verify password
if not self.verify_password(password, user.password_hash):
    return None  # Authentication failed
```

**Password Hashing:**
- **Algorithm:** Bcrypt (via `passlib`)
- **Salt:** Automatically generated by bcrypt
- **Hash Format:** `$2b$12$...` (bcrypt standard format)
- **Verification:** Uses `pwd_context.verify(plain_password, hashed_password)`

**Example Hash:**
```
$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYqBWVHxkd0
```

### 3. User Status Check

```python
if not user.is_active:
    return None  # User is inactive/suspended
```

**Status Values:**
- `'active'` - User can login ✅
- `'inactive'` - User cannot login ❌
- `'pending'` - User cannot login (awaiting activation) ❌
- `'suspended'` - User cannot login (temporarily banned) ❌

### 4. JWT Token Creation

After successful authentication:

```python
token = auth_service.create_access_token(user_data)
```

**Token Contents:**
```json
{
  "user_id": 1,
  "email": "user@example.com",
  "name": "John Doe",
  "user_type": "customer",
  "is_admin": false,
  "is_customer": true,
  "is_super_admin": false,
  "permissions": ["view_own_appointments", ...],
  "exp": 1234567890,  // Expiration timestamp
  "iat": 1234567890,  // Issued at timestamp
  "type": "access_token"
}
```

**Token Settings:**
- **Algorithm:** HS256 (HMAC-SHA256)
- **Expiration:** 24 hours (1440 minutes)
- **Secret Key:** From `ENCRYPTION_KEY` environment variable (base64 encoded)

---

## Complete Authentication Flow

```
1. User submits: POST /api/auth/login
   {
     "email": "user@example.com",
     "password": "plaintext_password"
   }

2. Backend queries database:
   SELECT * FROM users WHERE email ILIKE 'user@example.com'

3. If user not found → Return 401

4. Verify password:
   bcrypt.verify(plaintext_password, user.password_hash)

5. If password wrong → Return 401

6. Check user status:
   if user.status != 'active' → Return 401

7. Create JWT token with user data

8. Set auth cookie (optional, for web apps)

9. Return token and user info:
   {
     "token": "eyJhbGci...",
     "user": {
       "id": 1,
       "email": "user@example.com",
       ...
     }
   }
```

---

## Password Hashing Details

### Creating a Password Hash

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Hash a new password
hashed = pwd_context.hash("my_password")
# Returns: $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYqBWVHxkd0
```

### Verifying a Password

```python
# Verify password against hash
is_valid = pwd_context.verify("my_password", hashed)
# Returns: True or False
```

### Bcrypt Settings

- **Rounds:** 12 (default, good balance of security and performance)
- **Salt:** Automatically generated (unique per password)
- **Format:** `$2b$12$salt22chars$hash31chars`

**Why Bcrypt?**
- **Slow by design** - Resistant to brute force attacks
- **Adaptive** - Can increase rounds as hardware improves
- **Industry standard** - Widely used and trusted
- **Salt included** - Each hash has unique salt (prevents rainbow table attacks)

---

## User Types and Permissions

### Admin Users

**User Type:** `user_type = 'admin'`

**Properties:**
- `is_admin = True`
- `is_customer = False`
- Can have `is_super_admin = True` for elevated privileges

**Permissions:**
```python
[
  "view_appointments",
  "create_appointments",
  "edit_appointments",
  "delete_appointments",
  "view_customers",
  "create_customers",
  "edit_customers"
]

# Super admins also get:
[
  "manage_admins",
  "view_system_logs",
  "system_settings",
  "delete_customers"
]
```

### Customer Users

**User Type:** `user_type = 'customer'`

**Properties:**
- `is_admin = False`
- `is_customer = True`
- `is_super_admin = False`

**Permissions:**
```python
[
  "view_own_appointments",
  "create_own_appointments",
  "edit_own_appointments"
]
```

---

## Database Queries

### Finding a User by Email

```python
from database.models import User
from sqlalchemy.orm import Session

# Case-insensitive email lookup
user = db.query(User).filter(User.email.ilike("user@example.com")).first()

if user:
    print(f"Found user: {user.name} ({user.user_type})")
```

### Creating a New User

```python
from services.auth_service import AuthService

auth_service = AuthService(db)

# Hash the password
password_hash = auth_service.hash_password("new_password")

# Create user
new_user = User(
    email="newuser@example.com",
    password_hash=password_hash,
    user_type="customer",
    status="active",
    name="New User"
)

db.add(new_user)
db.commit()
```

### Updating a Password

```python
from services.auth_service import AuthService

auth_service = AuthService(db)

# Get user
user = db.query(User).filter(User.email == "user@example.com").first()

# Hash new password
user.password_hash = auth_service.hash_password("new_password")

db.commit()
```

### Checking User Status

```python
# Check if user is active
if user.status == 'active' and user.is_active:
    # User can login
    pass
```

---

## Security Considerations

### Password Storage

✅ **DO:**
- Store bcrypt hashes (never plain text)
- Use strong, unique passwords
- Hash passwords server-side
- Use HTTPS for all authentication requests

❌ **DON'T:**
- Store passwords in plain text
- Use weak hashing algorithms (MD5, SHA1)
- Send passwords in URL parameters
- Log passwords anywhere

### Token Security

✅ **DO:**
- Use HTTPS for token transmission
- Set appropriate token expiration (24 hours)
- Validate tokens on every request
- Check user status on token verification

❌ **DON'T:**
- Store tokens in localStorage (use httpOnly cookies if possible)
- Use tokens after expiration
- Share tokens between users
- Include sensitive data in tokens

### Database Security

✅ **DO:**
- Use parameterized queries (SQLAlchemy does this)
- Limit database user permissions
- Use connection pooling
- Encrypt database connections (SSL/TLS)

---

## Environment Variables

**Required:**
```bash
ENCRYPTION_KEY=<base64_encoded_secret_key>  # For JWT signing
DATABASE_URL=postgresql://user:pass@host:port/dbname
```

**Optional:**
```bash
ENVIRONMENT=production  # or 'development'
HTTPS_ENABLED=true
```

---

## Example: Complete Login Process

```python
# 1. Receive login request
POST /api/auth/login
{
  "email": "user@example.com",
  "password": "password123"
}

# 2. Query database
user = db.query(User).filter(User.email.ilike("user@example.com")).first()

# 3. Verify password
if not auth_service.verify_password("password123", user.password_hash):
    return 401

# 4. Check status
if user.status != 'active':
    return 401

# 5. Create token
token = auth_service.create_access_token({
    "user_id": user.id,
    "email": user.email,
    "user_type": user.user_type,
    ...
})

# 6. Return response
{
  "token": "eyJhbGci...",
  "user": {
    "id": 1,
    "email": "user@example.com",
    "name": "John Doe",
    "user_type": "customer",
    ...
  }
}
```

---

## Troubleshooting

### User Not Found

**Check:**
- Email is correct (case-insensitive)
- User exists in database
- Database connection is working

**Query:**
```sql
SELECT * FROM users WHERE email ILIKE 'user@example.com';
```

### Invalid Password

**Check:**
- Password is correct
- Password hash is valid bcrypt format
- Password wasn't corrupted in database

**Verify hash format:**
```python
# Should start with $2b$ or $2a$
hash.startswith('$2b$')  # True
```

### User Inactive

**Check:**
- User status is 'active'
- User wasn't suspended

**Query:**
```sql
SELECT email, status FROM users WHERE email = 'user@example.com';
```

### Token Invalid

**Check:**
- Token hasn't expired (24 hours)
- Token signature is valid
- ENCRYPTION_KEY matches between token creation and verification

---

## Summary

1. **Database:** Unified `users` table stores all accounts
2. **Lookup:** Case-insensitive email search
3. **Password:** Bcrypt hashing via passlib
4. **Verification:** Check password hash, user status, and permissions
5. **Token:** JWT with 24-hour expiration
6. **Security:** Bcrypt hashing, HTTPS, token expiration, status checks

The authentication system is designed to be secure, scalable, and easy to integrate with external applications.

